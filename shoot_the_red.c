/* Generated by Nelua 0.2.0-dev */
/* Compile command: gcc -x c "shoot_the_red.c" -x none -pipe -fwrapv -fno-strict-aliasing -g -lraylib -lm -o "shoot_the_red" */
/* Compile hash: 2skS8UarD2zF5CWdXjizAvBkQ9NF */
/* ------------------------------ DIRECTIVES -------------------------------- */
/* Disable some warnings that the generated code can trigger. */
#if defined(__clang__) && __clang_major__ >= 3
  #pragma clang diagnostic ignored "-Wtype-limits"
  #pragma clang diagnostic ignored "-Wwrite-strings"
  #pragma clang diagnostic ignored "-Wunused"
  #pragma clang diagnostic ignored "-Wunused-parameter"
  #pragma clang diagnostic ignored "-Wmissing-field-initializers"
  #pragma clang diagnostic ignored "-Wparentheses-equality"
  #pragma clang diagnostic ignored "-Wtautological-compare"
  #ifndef __cplusplus
    #pragma clang diagnostic ignored "-Wmissing-braces"
    #pragma clang diagnostic ignored "-Wincompatible-pointer-types"
    #pragma clang diagnostic error   "-Wimplicit-function-declaration"
    #pragma clang diagnostic error   "-Wimplicit-int"
  #else
    #pragma clang diagnostic ignored "-Wnarrowing"
  #endif
#elif defined(__GNUC__) && __GNUC__ >= 5
  #pragma GCC diagnostic ignored "-Wtype-limits"
  #pragma GCC diagnostic ignored "-Wwrite-strings"
  #pragma GCC diagnostic ignored "-Wunused-parameter"
  #pragma GCC diagnostic ignored "-Wunused-value"
  #pragma GCC diagnostic ignored "-Wunused-variable"
  #pragma GCC diagnostic ignored "-Wunused-function"
  #pragma GCC diagnostic ignored "-Wunused-but-set-variable"
  #pragma GCC diagnostic ignored "-Wmissing-field-initializers"
  #ifndef __cplusplus
    #pragma GCC diagnostic ignored "-Wmissing-braces"
    #pragma GCC diagnostic ignored "-Wincompatible-pointer-types"
    #pragma GCC diagnostic ignored "-Wdiscarded-qualifiers"
    #pragma GCC diagnostic error   "-Wimplicit-function-declaration"
    #pragma GCC diagnostic error   "-Wimplicit-int"
  #else
    #pragma GCC diagnostic ignored "-Wnarrowing"
  #endif
#endif
#if defined(_WIN32) && !defined(_CRT_SECURE_NO_WARNINGS)
  #define _CRT_SECURE_NO_WARNINGS
#endif
/* Macro used to perform compile-time checks. */
#if __STDC_VERSION__ >= 201112L
  #define NELUA_STATIC_ASSERT _Static_assert
#elif __cplusplus >= 201103L
  #define NELUA_STATIC_ASSERT static_assert
#else
  #define NELUA_STATIC_ASSERT(x, y)
#endif
/* Macro used to get alignment of a type. */
#if __STDC_VERSION__ >= 201112L
  #define NELUA_ALIGNOF _Alignof
#elif __cplusplus >= 201103L
  #define NELUA_ALIGNOF alignof
#elif defined(__GNUC__)
  #define NELUA_ALIGNOF __alignof__
#elif defined(_MSC_VER)
  #define NELUA_ALIGNOF __alignof
#else
  #define NELUA_ALIGNOF(x)
#endif
/* Checks if Nelua and C agrees on pointer size. */
NELUA_STATIC_ASSERT(sizeof(void*) == 8 && NELUA_ALIGNOF(void*) == 8, "Nelua and C disagree on pointer size or alignment");
/* Enable 64 bit offsets for stdio APIs. */
#if !defined(_FILE_OFFSET_BITS) && __SIZEOF_LONG__ >= 8
  #define _FILE_OFFSET_BITS 64
#endif
/* Enable POSIX APIs in included headers. */
#if !defined(_POSIX_C_SOURCE) && !defined(_XOPEN_SOURCE) && !defined(_GNU_SOURCE) && !defined(_DEFAULT_SOURCE)
  #if defined(__gnu_linux__)
    #define _GNU_SOURCE
  #else
    #define _XOPEN_SOURCE 600
  #endif
#endif
#include <string.h>
/* Macro used to force inlining a function. */
#ifdef __GNUC__
  #define NELUA_INLINE __attribute__((always_inline)) inline
#elif defined(_MSC_VER)
  #define NELUA_INLINE __forceinline
#elif __STDC_VERSION__ >= 199901L
  #define NELUA_INLINE inline
#else
  #define NELUA_INLINE
#endif
#include <stdint.h>
/* Macro used for branch prediction. */
#if defined(__GNUC__) || defined(__clang__)
  #define NELUA_UNLIKELY(x) __builtin_expect(x, 0)
#else
  #define NELUA_UNLIKELY(x) (x)
#endif
#include <stdio.h>
#include <stdlib.h>
/* Macro used to import/export extern C functions. */
#ifdef __cplusplus
  #define NELUA_EXTERN extern "C"
#else
  #define NELUA_EXTERN extern
#endif
/* Macro used to generate traceback on aborts when sanitizing. */
#if defined(__clang__) && defined(__has_feature)
  #if __has_feature(undefined_behavior_sanitizer)
    #define NELUA_UBSAN_UNREACHABLE __builtin_unreachable
  #endif
#elif defined(__gnu_linux__) && defined(__GNUC__) && __GNUC__ >= 5
  NELUA_EXTERN void __ubsan_handle_builtin_unreachable(void*) __attribute__((weak));
  #define NELUA_UBSAN_UNREACHABLE() {if(&__ubsan_handle_builtin_unreachable) __builtin_unreachable();}
#endif
#ifndef NELUA_UBSAN_UNREACHABLE
  #define NELUA_UBSAN_UNREACHABLE()
#endif
/* Macro used to specify a function that never returns. */
#if __STDC_VERSION__ >= 201112L
  #define NELUA_NORETURN _Noreturn
#elif defined(__GNUC__)
  #define NELUA_NORETURN __attribute__((noreturn))
#elif defined(_MSC_VER)
  #define NELUA_NORETURN __declspec(noreturn)
#else
  #define NELUA_NORETURN
#endif
#include <stdbool.h>
#include <stddef.h>
/* Macro used for branch prediction. */
#if defined(__GNUC__) || defined(__clang__)
  #define NELUA_LIKELY(x) __builtin_expect(x, 1)
#else
  #define NELUA_LIKELY(x) (x)
#endif
#define NELUA_NIL (nlniltype){}
/* Macro used to force not inlining a function. */
#ifdef __GNUC__
  #define NELUA_NOINLINE __attribute__((noinline))
#elif defined(_MSC_VER)
  #define NELUA_NOINLINE __declspec(noinline)
#else
  #define NELUA_NOINLINE
#endif
/* Macro used suppress sanitizer errors when the GC is scanning. */
#if defined(__has_feature)
  #if __has_feature(address_sanitizer)
    #define NELUA_GC_NO_SANITIZE __attribute__((no_sanitize_address))
  #elif __has_feature(memory_sanitizer)
    #define NELUA_GC_NO_SANITIZE __attribute__((no_sanitize_memory))
  #endif
#endif
#ifndef NELUA_GC_NO_SANITIZE
  #if defined(__SANITIZE_ADDRESS__)
    #define NELUA_GC_NO_SANITIZE __attribute__((no_sanitize_address))
  #else
    #define NELUA_GC_NO_SANITIZE
  #endif
#endif
#include <setjmp.h>
/* Macro used sign that a type punning cast may alias (related to strict aliasing). */
#ifdef __GNUC__
  #define NELUA_MAYALIAS __attribute__((may_alias))
#else
  #define NELUA_MAYALIAS
#endif
#include <raylib.h>
/* ------------------------------ DECLARATIONS ------------------------------ */
static NELUA_INLINE void nelua_memory_copy(void* dest, void* src, uintptr_t n);
static NELUA_NORETURN void nelua_abort(void);
typedef struct nlstring nlstring;
typedef uint8_t* nluint8_arr0_ptr;
struct nlstring {
  nluint8_arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nlstring) == 16 && NELUA_ALIGNOF(nlstring) == 8, "Nelua and C disagree on type size or align");
static void nelua_assert_line_1(bool cond, nlstring msg);
static NELUA_INLINE void nelua_memory_zero(void* dest, uintptr_t n);
static void nelua_assert_line_2(bool cond, nlstring msg);
typedef struct nelua_GCItem nelua_GCItem;
typedef nelua_GCItem* nelua_GCItem_ptr;
typedef struct nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr {
  bool r1;
  void* r2;
  nelua_GCItem_ptr r3;
} nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr;
typedef struct nelua_hashmap_iteratorT nelua_hashmap_iteratorT;
typedef nelua_hashmap_iteratorT* nelua_hashmap_iteratorT_ptr;
typedef nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr (*function_Y9ZBzLsq6u97x8ch)(nelua_hashmap_iteratorT_ptr, void*);
typedef struct nelua_hashmap_pointer__GCItem_ nelua_hashmap_pointer__GCItem_;
typedef nelua_hashmap_pointer__GCItem_* nelua_hashmap_pointer__GCItem__ptr;
struct nelua_hashmap_iteratorT {
  nelua_hashmap_pointer__GCItem__ptr container;
  uintptr_t index;
};
NELUA_STATIC_ASSERT(sizeof(nelua_hashmap_iteratorT) == 16 && NELUA_ALIGNOF(nelua_hashmap_iteratorT) == 8, "Nelua and C disagree on type size or align");
typedef struct nelua_span_usize_ nelua_span_usize_;
typedef uintptr_t* nlusize_arr0_ptr;
struct nelua_span_usize_ {
  nlusize_arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_usize_) == 16 && NELUA_ALIGNOF(nelua_span_usize_) == 8, "Nelua and C disagree on type size or align");
typedef struct nelua_span_hashmapnode_pointer__GCItem__ nelua_span_hashmapnode_pointer__GCItem__;
typedef struct nelua_hashmapnode_pointer__GCItem_ nelua_hashmapnode_pointer__GCItem_;
typedef nelua_hashmapnode_pointer__GCItem_* nelua_hashmapnode_pointer__GCItem__arr0_ptr;
struct nelua_span_hashmapnode_pointer__GCItem__ {
  nelua_hashmapnode_pointer__GCItem__arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_hashmapnode_pointer__GCItem__) == 16 && NELUA_ALIGNOF(nelua_span_hashmapnode_pointer__GCItem__) == 8, "Nelua and C disagree on type size or align");
typedef struct nelua_GeneralAllocator nelua_GeneralAllocator;
struct nelua_GeneralAllocator {};
struct nelua_hashmap_pointer__GCItem_ {
  nelua_span_usize_ buckets;
  nelua_span_hashmapnode_pointer__GCItem__ nodes;
  uintptr_t size;
  uintptr_t free_index;
  nelua_GeneralAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_hashmap_pointer__GCItem_) == 48 && NELUA_ALIGNOF(nelua_hashmap_pointer__GCItem_) == 8, "Nelua and C disagree on type size or align");
typedef void (*nelua_GCFinalizerCallback)(void*, void*);
struct nelua_GCItem {
  uintptr_t flags;
  uintptr_t size;
  void* ptr;
  nelua_GCFinalizerCallback finalizer;
  void* userdata;
};
NELUA_STATIC_ASSERT(sizeof(nelua_GCItem) == 40 && NELUA_ALIGNOF(nelua_GCItem) == 8, "Nelua and C disagree on type size or align");
struct nelua_hashmapnode_pointer__GCItem_ {
  void* key;
  nelua_GCItem value;
  bool filled;
  uintptr_t next;
};
NELUA_STATIC_ASSERT(sizeof(nelua_hashmapnode_pointer__GCItem_) == 64 && NELUA_ALIGNOF(nelua_hashmapnode_pointer__GCItem_) == 8, "Nelua and C disagree on type size or align");
typedef struct nlmulret_function_Y9ZBzLsq6u97x8ch_nelua_hashmap_iteratorT_nlpointer {
  function_Y9ZBzLsq6u97x8ch r1;
  nelua_hashmap_iteratorT r2;
  void* r3;
} nlmulret_function_Y9ZBzLsq6u97x8ch_nelua_hashmap_iteratorT_nlpointer;
static NELUA_INLINE nlmulret_function_Y9ZBzLsq6u97x8ch_nelua_hashmap_iteratorT_nlpointer nelua_mpairs_1(nelua_hashmap_pointer__GCItem__ptr a);
typedef void** nlpointer_ptr;
typedef struct nelua_span_pointer_ nelua_span_pointer_;
typedef nelua_span_pointer_* nelua_span_pointer__ptr;
typedef void** nlpointer_arr0_ptr;
struct nelua_span_pointer_ {
  nlpointer_arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_pointer_) == 16 && NELUA_ALIGNOF(nelua_span_pointer_) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE nlpointer_ptr nelua_span_pointer____atindex(nelua_span_pointer__ptr self, uintptr_t i);
static void nelua_assert_line_3(bool cond, nlstring msg);
typedef uintptr_t* nlusize_ptr;
typedef nelua_span_usize_* nelua_span_usize__ptr;
static NELUA_INLINE nlusize_ptr nelua_span_usize____atindex(nelua_span_usize__ptr self, uintptr_t i);
static void nelua_assert_line_4(bool cond, nlstring msg);
typedef nelua_hashmapnode_pointer__GCItem_* nelua_hashmapnode_pointer__GCItem__ptr;
typedef nelua_span_hashmapnode_pointer__GCItem__* nelua_span_hashmapnode_pointer__GCItem___ptr;
static NELUA_INLINE nelua_hashmapnode_pointer__GCItem__ptr nelua_span_hashmapnode_pointer__GCItem_____atindex(nelua_span_hashmapnode_pointer__GCItem___ptr self, uintptr_t i);
static void nelua_assert_line_5(bool cond, nlstring msg);
static NELUA_INLINE void nelua_memory_spanset_1(nelua_span_usize_ dest, uintptr_t x);
static NELUA_NORETURN void nelua_panic_cstring(const char* s);
static NELUA_INLINE void* nelua_assert_deref(void* p);
static nelua_GeneralAllocator nelua_general_allocator;
typedef nelua_GeneralAllocator* nelua_GeneralAllocator_ptr;
static NELUA_INLINE void* nelua_GeneralAllocator_alloc(nelua_GeneralAllocator_ptr self, uintptr_t size);
static NELUA_INLINE void* nelua_GeneralAllocator_alloc0(nelua_GeneralAllocator_ptr self, uintptr_t size);
static NELUA_INLINE void nelua_GeneralAllocator_dealloc(nelua_GeneralAllocator_ptr self, void* p);
static NELUA_INLINE void* nelua_GeneralAllocator_realloc(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize);
static void* nelua_GeneralAllocator_realloc0(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize);
typedef struct nlniltype {} nlniltype;
static nelua_span_pointer_ nelua_GeneralAllocator_spanalloc_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size);
static nelua_span_usize_ nelua_GeneralAllocator_spanalloc_2(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size);
static nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_spanalloc0_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size);
static void nelua_GeneralAllocator_spandealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s);
static void nelua_GeneralAllocator_spandealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s);
static void nelua_GeneralAllocator_spandealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s);
static nelua_span_pointer_ nelua_GeneralAllocator_spanrealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s, uintptr_t size);
static nelua_span_usize_ nelua_GeneralAllocator_spanrealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s, uintptr_t size);
static nelua_span_pointer_ nelua_GeneralAllocator_xspanrealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s, uintptr_t size);
static NELUA_NORETURN void nelua_panic_string(nlstring s);
static nelua_span_usize_ nelua_GeneralAllocator_xspanrealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s, uintptr_t size);
static nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_spanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s, uintptr_t size);
static nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_xspanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s, uintptr_t size);
static uintptr_t nelua_hash_hash_1(void* v);
static NELUA_INLINE uintptr_t nelua_ceilidiv(uintptr_t x, uintptr_t y);
static NELUA_INLINE uintptr_t nelua_hashmod(uintptr_t h, uintptr_t n);
static NELUA_INLINE uintptr_t nelua_roundpow2(uintptr_t n);
static void nelua_hashmap_pointer__GCItem__destroy(nelua_hashmap_pointer__GCItem__ptr self);
typedef struct nlmulret_nlusize_nlusize_nlusize {
  uintptr_t r1;
  uintptr_t r2;
  uintptr_t r3;
} nlmulret_nlusize_nlusize_nlusize;
static NELUA_INLINE nlmulret_nlusize_nlusize_nlusize nelua_hashmap_pointer__GCItem___find(nelua_hashmap_pointer__GCItem__ptr self, void* key);
static NELUA_NOINLINE void nelua_hashmap_pointer__GCItem__rehash(nelua_hashmap_pointer__GCItem__ptr self, uintptr_t bucket_count);
static void nelua_assert_line_6(bool cond);
static uintptr_t nelua_hashmap_pointer__GCItem___at(nelua_hashmap_pointer__GCItem__ptr self, void* key);
static void nelua_assert_line_7(bool cond, nlstring msg);
static nelua_GCItem_ptr nelua_hashmap_pointer__GCItem____atindex(nelua_hashmap_pointer__GCItem__ptr self, void* key);
static nelua_GCItem_ptr nelua_hashmap_pointer__GCItem__peek(nelua_hashmap_pointer__GCItem__ptr self, void* key);
static nelua_GCItem nelua_hashmap_pointer__GCItem__remove(nelua_hashmap_pointer__GCItem__ptr self, void* key);
static uintptr_t nelua_hashmap_pointer__GCItem__bucketcount(nelua_hashmap_pointer__GCItem__ptr self);
static NELUA_INLINE nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr nelua_hashmap_iteratorT_mnext(nelua_hashmap_iteratorT_ptr self, void* key);
static NELUA_INLINE nlmulret_function_Y9ZBzLsq6u97x8ch_nelua_hashmap_iteratorT_nlpointer nelua_hashmap_pointer__GCItem____mpairs(nelua_hashmap_pointer__GCItem__ptr self);
typedef struct nelua_vector_pointer_ nelua_vector_pointer_;
typedef nelua_vector_pointer_* nelua_vector_pointer__ptr;
struct nelua_vector_pointer_ {
  nelua_span_pointer_ data;
  uintptr_t size;
  nelua_GeneralAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_vector_pointer_) == 24 && NELUA_ALIGNOF(nelua_vector_pointer_) == 8, "Nelua and C disagree on type size or align");
static void nelua_vector_pointer__clear(nelua_vector_pointer__ptr self);
static void nelua_vector_pointer__destroy(nelua_vector_pointer__ptr self);
static NELUA_NOINLINE void nelua_vectorT_grow(nelua_vector_pointer__ptr self);
static void nelua_assert_line_8(bool cond, nlstring msg);
static void nelua_vector_pointer__push(nelua_vector_pointer__ptr self, void* v);
static NELUA_INLINE nlpointer_ptr nelua_vector_pointer____atindex(nelua_vector_pointer__ptr self, uintptr_t pos);
static void nelua_assert_line_9(bool cond, nlstring msg);
static NELUA_INLINE bool nelua_hasflag(uintptr_t flags, uintptr_t flag);
static NELUA_INLINE uintptr_t nelua_align_forward(uintptr_t addr, uintptr_t align);
static NELUA_INLINE bool nelua_GCItem_ismarked(nelua_GCItem_ptr self);
typedef struct nelua_GC nelua_GC;
struct nelua_GC {
  bool running;
  bool collecting;
  uintptr_t pause;
  uintptr_t membytes;
  uintptr_t lastmembytes;
  uintptr_t minaddr;
  uintptr_t maxaddr;
  uintptr_t stacktop;
  uintptr_t stackbottom;
  nelua_vector_pointer_ frees;
  nelua_hashmap_pointer__GCItem_ items;
};
NELUA_STATIC_ASSERT(sizeof(nelua_GC) == 136 && NELUA_ALIGNOF(nelua_GC) == 8, "Nelua and C disagree on type size or align");
static nelua_GC nelua_gc;
typedef nelua_GC* nelua_GC_ptr;
static bool nelua_GC_unregister_1(nelua_GC_ptr self, void* ptr, bool finalize);
static NELUA_NOINLINE NELUA_GC_NO_SANITIZE void nelua_GC_markptrs(nelua_GC_ptr self, uintptr_t low, uintptr_t high);
static NELUA_NOINLINE void nelua_GC_unmarkall(nelua_GC_ptr self);
static NELUA_NOINLINE void nelua_GC_markroot(nelua_GC_ptr self);
static NELUA_NOINLINE void nelua_GC_markstack(nelua_GC_ptr self);
typedef union nelua_RegsBuf nelua_RegsBuf;
union nelua_RegsBuf {
  jmp_buf regs;
  void* firstreg;
};
static NELUA_INLINE uintptr_t nelua_assert_narrow_nlint64_nlusize(int64_t x);
static void nelua_GC_mark(nelua_GC_ptr self);
typedef void (*function_5MrVRYcrg5F8fqJVF)(nelua_GC_ptr);
static NELUA_NOINLINE void nelua_GC_sweep(nelua_GC_ptr self);
static void nelua_assert_line_10(bool cond, nlstring msg);
static void nelua_assert_line_11(bool cond, nlstring msg);
static NELUA_NOINLINE void nelua_GC_collect(nelua_GC_ptr self);
static void nelua_GC_registerroots(nelua_GC_ptr self);
typedef void (*function_32GqvTv12hiL63Ei3)(void*, void*);
static void nelua_GC_maybecollect(nelua_GC_ptr self);
static void nelua_GC_register(nelua_GC_ptr self, void* ptr, uintptr_t size, uintptr_t flags, function_32GqvTv12hiL63Ei3 finalizer, void* userdata);
static void nelua_assert_line_12(bool cond, nlstring msg);
static void nelua_GC_restart(nelua_GC_ptr self);
static NELUA_NOINLINE void nelua_GC_init(nelua_GC_ptr self, void* stack);
static NELUA_NOINLINE void nelua_GC_destroy(nelua_GC_ptr self);
typedef char** nlcstring_ptr;
int main(int argc, nlcstring_ptr argv);
typedef int (*function_2PF4zy9rEcTmN3kR7)(int, nlcstring_ptr);
typedef struct nelua_GCAllocator nelua_GCAllocator;
struct nelua_GCAllocator {};
static nelua_GCAllocator nelua_gc_allocator;
typedef nelua_GCAllocator* nelua_GCAllocator_ptr;
static NELUA_NOINLINE void* nelua_GCAllocator_alloc_1(nelua_GCAllocator_ptr self, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata);
static NELUA_NOINLINE void nelua_GCAllocator_dealloc(nelua_GCAllocator_ptr self, void* ptr);
static void* nelua_GCAllocator_xalloc(nelua_GCAllocator_ptr self, uintptr_t size);
static nlstring nelua_nlstring_create(uintptr_t size);
static void nelua_assert_line_13(bool cond, nlstring msg);
typedef nlstring* nlstring_ptr;
static void nelua_nlstring_destroy(nlstring_ptr self);
static nlstring nelua_nlstring_copy(nlstring s);
static nlstring nelua_nlstring___concat_2(nlstring a, int64_t b);
static nlstring nelua_int2str_1(intptr_t x, nlniltype base);
typedef struct NELUA_MAYALIAS nluint8_arr48 {uint8_t v[48];} nluint8_arr48;
typedef union NELUA_MAYALIAS nluint8_arr48_cast {nluint8_arr48 a; uint8_t p[48];} nluint8_arr48_cast;
NELUA_STATIC_ASSERT(sizeof(nluint8_arr48) == 48 && NELUA_ALIGNOF(nluint8_arr48) == 1, "Nelua and C disagree on type size or align");
static NELUA_INLINE uintptr_t nelua_assert_bounds_nlusize(uintptr_t index, uintptr_t len);
static nlstring nelua_tostring_2(int64_t x);
static NELUA_NORETURN void nelua_os_exit_1(nlniltype code);
static Rectangle main_scrn;
static Rectangle main_plr = {0.0f, 0.0f, 50.0f, 50.0f};
static Rectangle main_enemy;
typedef struct NELUA_MAYALIAS Vector2_arr2 {Vector2 v[2];} Vector2_arr2;
typedef union NELUA_MAYALIAS Vector2_arr2_cast {Vector2_arr2 a; Vector2 p[2];} Vector2_arr2_cast;
NELUA_STATIC_ASSERT(sizeof(Vector2_arr2) == 16 && NELUA_ALIGNOF(Vector2_arr2) == 4, "Nelua and C disagree on type size or align");
static Vector2_arr2 main_line = {.v = {{0.0f, 0.0f}, {0.0f, 0.0f}}};
static int64_t main_score = 0;
static Camera2D main_camera;
typedef struct NELUA_MAYALIAS nlint64_arr4 {int64_t v[4];} nlint64_arr4;
typedef union NELUA_MAYALIAS nlint64_arr4_cast {nlint64_arr4 a; int64_t p[4];} nlint64_arr4_cast;
NELUA_STATIC_ASSERT(sizeof(nlint64_arr4) == 32 && NELUA_ALIGNOF(nlint64_arr4) == 8, "Nelua and C disagree on type size or align");
static nlint64_arr4 main_dict = {.v = {-1, 1, -1, 1}};
typedef struct main_bullet main_bullet;
typedef int64_t main_direct;
struct main_bullet {
  Rectangle pos;
  main_direct dir;
};
NELUA_STATIC_ASSERT(sizeof(main_bullet) == 24 && NELUA_ALIGNOF(main_bullet) == 8, "Nelua and C disagree on type size or align");
static main_bullet main_newblt = {{10.0f, 10.0f, 30.0f, 5.0f}};
static int64_t main_direction;
static Sound main_shootsnd;
static Sound main_hit;
static bool main_shoot = false;
static void nelua_print_1(nlstring a1);
static void nelua_print_2(int64_t a1);
static void nelua_print_3(float a1, float a2);
static NELUA_INLINE main_direct nelua_assert_bounds_main_direct(main_direct index, uintptr_t len);
static NELUA_INLINE char* nelua_assert_string2cstring(nlstring s);
static int nelua_main(int nelua_argc, char** nelua_argv);
/* ------------------------------ DEFINITIONS ------------------------------- */
void nelua_abort(void) {
  NELUA_UBSAN_UNREACHABLE();
  abort();
}
void nelua_assert_line_1(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/memory.nelua\033[1m:27:14: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 81, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n  check(dest and src, 'invalid pointer')\n             \033[1m\033[32m^\033[0m\033[35m~~~~~~\033[0m\n", 1, 89, stderr);
    fflush(stderr);
    nelua_abort();
  }
}
void nelua_memory_copy(void* dest, void* src, uintptr_t n) {
  if(NELUA_UNLIKELY((n == 0))) {
    return;
  }
  nelua_assert_line_1(((dest != NULL) && (src != NULL)), ((nlstring){(uint8_t*)"invalid pointer", 15}));
  memcpy(dest, src, (size_t)n);
}
void nelua_assert_line_2(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/memory.nelua\033[1m:60:9: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 80, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n  check(dest, 'invalid pointer')\n        \033[1m\033[32m^\033[0m\033[35m~~~\033[0m\n", 1, 73, stderr);
    fflush(stderr);
    nelua_abort();
  }
}
void nelua_memory_zero(void* dest, uintptr_t n) {
  if(NELUA_UNLIKELY((n == 0))) {
    return;
  }
  nelua_assert_line_2((dest != NULL), ((nlstring){(uint8_t*)"invalid pointer", 15}));
  memset(dest, 0, (size_t)n);
}
nlmulret_function_Y9ZBzLsq6u97x8ch_nelua_hashmap_iteratorT_nlpointer nelua_mpairs_1(nelua_hashmap_pointer__GCItem__ptr a) {
  nlmulret_function_Y9ZBzLsq6u97x8ch_nelua_hashmap_iteratorT_nlpointer _ret_1 = nelua_hashmap_pointer__GCItem____mpairs(a);
  return (nlmulret_function_Y9ZBzLsq6u97x8ch_nelua_hashmap_iteratorT_nlpointer){_ret_1.r1, _ret_1.r2, _ret_1.r3};
}
void nelua_assert_line_3(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/span.nelua\033[1m:78:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 79, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 1, 98, stderr);
    fflush(stderr);
    nelua_abort();
  }
}
nlpointer_ptr nelua_span_pointer____atindex(nelua_span_pointer__ptr self, uintptr_t i) {
  nelua_assert_line_3((i < self->size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self->data[i]);
}
void nelua_assert_line_4(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/span.nelua\033[1m:78:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 79, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 1, 98, stderr);
    fflush(stderr);
    nelua_abort();
  }
}
nlusize_ptr nelua_span_usize____atindex(nelua_span_usize__ptr self, uintptr_t i) {
  nelua_assert_line_4((i < self->size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self->data[i]);
}
void nelua_assert_line_5(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/span.nelua\033[1m:78:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 79, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 1, 98, stderr);
    fflush(stderr);
    nelua_abort();
  }
}
nelua_hashmapnode_pointer__GCItem__ptr nelua_span_hashmapnode_pointer__GCItem_____atindex(nelua_span_hashmapnode_pointer__GCItem___ptr self, uintptr_t i) {
  nelua_assert_line_5((i < self->size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self->data[i]);
}
void nelua_panic_cstring(const char* s) {
  fputs(s, stderr);
  fputc('\n', stderr);
  fflush(stderr);
  nelua_abort();
}
void* nelua_assert_deref(void* p) {
  if(NELUA_UNLIKELY(p == NULL)) {
    nelua_panic_cstring("attempt to dereference a null pointer");
  }
  return p;
}
void nelua_memory_spanset_1(nelua_span_usize_ dest, uintptr_t x) {
  for(uintptr_t i = 0U, _end = dest.size; i < _end; i = i + 1) {
    memcpy((void*)(&(*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex((&dest), i)))), (void*)(&x), 8U);
  }
}
void* nelua_GeneralAllocator_alloc(nelua_GeneralAllocator_ptr self, uintptr_t size) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  return malloc((size_t)size);
}
void* nelua_GeneralAllocator_alloc0(nelua_GeneralAllocator_ptr self, uintptr_t size) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  return calloc((size_t)size, 1U);
}
void nelua_GeneralAllocator_dealloc(nelua_GeneralAllocator_ptr self, void* p) {
  if(NELUA_UNLIKELY((p == (void*)NULL))) {
    return;
  }
  free(p);
}
void* nelua_GeneralAllocator_realloc(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize) {
  if(NELUA_UNLIKELY((newsize == 0))) {
    if(NELUA_LIKELY((p != (void*)NULL))) {
      free(p);
    }
    return (void*)NULL;
  } else if(NELUA_UNLIKELY((newsize == oldsize))) {
    return p;
  }
  return realloc(p, (size_t)newsize);
}
void* nelua_GeneralAllocator_realloc0(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize) {
  p = nelua_GeneralAllocator_realloc(self, p, newsize, oldsize);
  if(NELUA_LIKELY(((newsize > oldsize) && (p != (void*)NULL)))) {
    nelua_memory_zero((void*)(&((nluint8_arr0_ptr)p)[oldsize]), (newsize - oldsize));
  }
  return p;
}
nelua_span_pointer_ nelua_GeneralAllocator_spanalloc_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size) {
  if(NELUA_LIKELY((size > 0))) {
    nlpointer_arr0_ptr data = ((nlpointer_arr0_ptr)nelua_GeneralAllocator_alloc(self, (size * 8)));
    if(NELUA_LIKELY((data != ((nlpointer_arr0_ptr)NULL)))) {
      return (nelua_span_pointer_){data, size};
    }
  }
  return (nelua_span_pointer_){0};
}
nelua_span_usize_ nelua_GeneralAllocator_spanalloc_2(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size) {
  if(NELUA_LIKELY((size > 0))) {
    nlusize_arr0_ptr data = ((nlusize_arr0_ptr)nelua_GeneralAllocator_alloc(self, (size * 8)));
    if(NELUA_LIKELY((data != ((nlusize_arr0_ptr)NULL)))) {
      return (nelua_span_usize_){data, size};
    }
  }
  return (nelua_span_usize_){0};
}
nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_spanalloc0_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size) {
  if(NELUA_LIKELY((size > 0))) {
    nelua_hashmapnode_pointer__GCItem__arr0_ptr data = ((nelua_hashmapnode_pointer__GCItem__arr0_ptr)nelua_GeneralAllocator_alloc0(self, (size * 64)));
    if(NELUA_LIKELY((data != ((nelua_hashmapnode_pointer__GCItem__arr0_ptr)NULL)))) {
      return (nelua_span_hashmapnode_pointer__GCItem__){data, size};
    }
  }
  return (nelua_span_hashmapnode_pointer__GCItem__){0};
}
void nelua_GeneralAllocator_spandealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s) {
  if(NELUA_UNLIKELY((s.size == 0))) {
    return;
  }
  nelua_GeneralAllocator_dealloc(self, (void*)s.data);
}
void nelua_GeneralAllocator_spandealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s) {
  if(NELUA_UNLIKELY((s.size == 0))) {
    return;
  }
  nelua_GeneralAllocator_dealloc(self, (void*)s.data);
}
void nelua_GeneralAllocator_spandealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s) {
  if(NELUA_UNLIKELY((s.size == 0))) {
    return;
  }
  nelua_GeneralAllocator_dealloc(self, (void*)s.data);
}
nelua_span_pointer_ nelua_GeneralAllocator_spanrealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc_1(self, NELUA_NIL, size);
    return s;
  }
  nlpointer_arr0_ptr p = ((nlpointer_arr0_ptr)nelua_GeneralAllocator_realloc(self, (void*)s.data, (size * 8), s.size));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nlpointer_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_usize_ nelua_GeneralAllocator_spanrealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc_2(self, NELUA_NIL, size);
    return s;
  }
  nlusize_arr0_ptr p = ((nlusize_arr0_ptr)nelua_GeneralAllocator_realloc(self, (void*)s.data, (size * 8), s.size));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nlusize_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
void nelua_panic_string(nlstring s) {
  if(s.size > 0) {
    fwrite(s.data, 1, s.size, stderr);
    fputc('\n', stderr);
    fflush(stderr);
  }
  nelua_abort();
}
nelua_span_pointer_ nelua_GeneralAllocator_xspanrealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc_1(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_usize_ nelua_GeneralAllocator_xspanrealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc_2(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_spanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc0_1(self, NELUA_NIL, size);
    return s;
  }
  nelua_hashmapnode_pointer__GCItem__arr0_ptr p = ((nelua_hashmapnode_pointer__GCItem__arr0_ptr)nelua_GeneralAllocator_realloc0(self, (void*)s.data, (size * 64), (s.size * 64)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nelua_hashmapnode_pointer__GCItem__arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_xspanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc0_1(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
uintptr_t nelua_hash_hash_1(void* v) {
  return ((uintptr_t)v >> 3);
}
uintptr_t nelua_ceilidiv(uintptr_t x, uintptr_t y) {
  return (((x + y) - 1) / y);
}
uintptr_t nelua_hashmod(uintptr_t h, uintptr_t n) {
  return (h % ((n - 1) | 1));
}
uintptr_t nelua_roundpow2(uintptr_t n) {
  if(((n & (n - 1)) == 0)) {
    return n;
  }
  n = (n | (n >> 1));
  n = (n | (n >> 2));
  n = (n | (n >> 4));
  n = (n | (n >> 8));
  n = (n | (n >> 16));
  n = (n | (n >> 32));
  n = (n + 1);
  return n;
}
void nelua_hashmap_pointer__GCItem__destroy(nelua_hashmap_pointer__GCItem__ptr self) {
  nelua_GeneralAllocator_spandealloc_2((&self->allocator), self->buckets);
  nelua_GeneralAllocator_spandealloc_3((&self->allocator), self->nodes);
  self->buckets = (nelua_span_usize_){0};
  self->nodes = (nelua_span_hashmapnode_pointer__GCItem__){0};
  self->size = 0U;
  self->free_index = 0U;
}
nlmulret_nlusize_nlusize_nlusize nelua_hashmap_pointer__GCItem___find(nelua_hashmap_pointer__GCItem__ptr self, void* key) {
  uintptr_t hash_index = nelua_hashmod(nelua_hash_hash_1(key), self->buckets.size);
  uintptr_t prev_node_index = 0xffffffffffffffffULL;
  if(NELUA_UNLIKELY((self->buckets.size == 0))) {
    return (nlmulret_nlusize_nlusize_nlusize){0xffffffffffffffffULL, prev_node_index, hash_index};
  }
  uintptr_t node_index = (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex((&self->buckets), hash_index)));
  while((node_index != 0xffffffffffffffffULL)) {
    nelua_hashmapnode_pointer__GCItem__ptr node = (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), node_index))));
    if(NELUA_LIKELY((node->key == key))) {
      return (nlmulret_nlusize_nlusize_nlusize){node_index, prev_node_index, hash_index};
    }
    prev_node_index = node_index;
    node_index = node->next;
  }
  return (nlmulret_nlusize_nlusize_nlusize){node_index, prev_node_index, hash_index};
}
void nelua_assert_line_6(bool cond) {
  if(NELUA_UNLIKELY(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/hashmap.nelua\033[1m:200:15: \033[31m\033[1mruntime error: \033[0m\033[1massertion failed!\033[0m\n      check(j == self.size)\n              \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~\033[0m\n", 1, 182, stderr);
    fflush(stderr);
    nelua_abort();
  }
}
void nelua_hashmap_pointer__GCItem__rehash(nelua_hashmap_pointer__GCItem__ptr self, uintptr_t bucket_count) {
  uintptr_t min_buckets_count = nelua_ceilidiv((self->size * 100), 75U);
  if((bucket_count < min_buckets_count)) {
    bucket_count = min_buckets_count;
  }
  bucket_count = nelua_roundpow2(bucket_count);
  uintptr_t node_count = nelua_ceilidiv((bucket_count * 75U), 100U);
  if(((bucket_count > 0) && (node_count <= self->size))) {
    node_count = (self->size + 1);
  }
  if((((node_count < self->nodes.size) && (self->nodes.size > 0)) && (node_count > 0))) {
    uintptr_t j = 0U;
    while(((j < self->nodes.size) && (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), j))).filled)) {
      j = (j + 1);
    }
    for(uintptr_t i = j, _end = self->nodes.size; i < _end; i = i + 1) {
      if((*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), i))).filled) {
        (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), j))) = (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), i)));
        j = (j + 1);
      }
    }
    for(uintptr_t i = j, _end = self->nodes.size; i < _end; i = i + 1) {
      (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), i))) = (nelua_hashmapnode_pointer__GCItem_){0};
    }
    nelua_assert_line_6((j == self->size));
  }
  self->nodes = nelua_GeneralAllocator_xspanrealloc0_1((&self->allocator), self->nodes, node_count);
  self->buckets = nelua_GeneralAllocator_xspanrealloc_2((&self->allocator), self->buckets, bucket_count);
  nelua_memory_spanset_1(self->buckets, 0xffffffffffffffffULL);
  uintptr_t free_index = 0xffffffffffffffffULL;
  for(intptr_t i = (intptr_t)(self->nodes.size - 1); i >= 0; i = i + -1) {
    nelua_hashmapnode_pointer__GCItem__ptr node = (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), (uintptr_t)i))));
    if(node->filled) {
      node->next = 0xffffffffffffffffULL;
    } else {
      node->next = free_index;
      free_index = (uintptr_t)i;
    }
  }
  self->free_index = free_index;
  for(uintptr_t i = 0U, _end = self->nodes.size; i < _end; i = i + 1) {
    if((*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), i))).filled) {
      nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_pointer__GCItem___find(self, (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), i))).key);
      uintptr_t node_index = _asgnret_1.r1;
      uintptr_t prev_node_index = _asgnret_1.r2;
      uintptr_t hash_index = _asgnret_1.r3;
      if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
        (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex((&self->buckets), hash_index))) = i;
      } else {
        (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), prev_node_index))).next = i;
      }
      (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), i))).next = node_index;
    }
  }
}
void nelua_assert_line_7(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/hashmap.nelua\033[1m:256:24: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 83, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n      check(node_index < self.nodes.size, 'not enough space to add a node')\n                       \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~\033[0m\n", 1, 144, stderr);
    fflush(stderr);
    nelua_abort();
  }
}
uintptr_t nelua_hashmap_pointer__GCItem___at(nelua_hashmap_pointer__GCItem__ptr self, void* key) {
  if(NELUA_UNLIKELY((self->buckets.size == 0))) {
    nelua_hashmap_pointer__GCItem__rehash(self, 16U);
  }
  nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_pointer__GCItem___find(self, key);
  uintptr_t node_index = _asgnret_1.r1;
  uintptr_t prev_node_index = _asgnret_1.r2;
  uintptr_t hash_index = _asgnret_1.r3;
  if((node_index != 0xffffffffffffffffULL)) {
    return node_index;
  } else {
    uintptr_t node_index_1 = self->free_index;
    nelua_assert_line_7((node_index_1 < self->nodes.size), ((nlstring){(uint8_t*)"not enough space to add a node", 30}));
    nelua_hashmapnode_pointer__GCItem__ptr node = (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), node_index_1))));
    self->free_index = node->next;
    (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(node)) = (nelua_hashmapnode_pointer__GCItem_){.key = key, .filled = true, .next = 0xffffffffffffffffULL};
    if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
      (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex((&self->buckets), hash_index))) = node_index_1;
    } else {
      (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), prev_node_index))).next = node_index_1;
    }
    self->size = (self->size + 1);
    if(NELUA_UNLIKELY(((self->size * 100) >= (self->buckets.size * 75U)))) {
      nelua_hashmap_pointer__GCItem__rehash(self, nelua_ceilidiv((self->size * 200U), 75U));
    }
    return node_index_1;
  }
}
nelua_GCItem_ptr nelua_hashmap_pointer__GCItem____atindex(nelua_hashmap_pointer__GCItem__ptr self, void* key) {
  return (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), nelua_hashmap_pointer__GCItem___at(self, key)))).value);
}
nelua_GCItem_ptr nelua_hashmap_pointer__GCItem__peek(nelua_hashmap_pointer__GCItem__ptr self, void* key) {
  uintptr_t node_index = nelua_hashmap_pointer__GCItem___find(self, key).r1;
  if((node_index != 0xffffffffffffffffULL)) {
    return (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), node_index))).value);
  }
  return ((nelua_GCItem_ptr)NULL);
}
nelua_GCItem nelua_hashmap_pointer__GCItem__remove(nelua_hashmap_pointer__GCItem__ptr self, void* key) {
  nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_pointer__GCItem___find(self, key);
  uintptr_t node_index = _asgnret_1.r1;
  uintptr_t prev_node_index = _asgnret_1.r2;
  uintptr_t hash_index = _asgnret_1.r3;
  if(NELUA_UNLIKELY((node_index == 0xffffffffffffffffULL))) {
    return (nelua_GCItem){0};
  }
  nelua_hashmapnode_pointer__GCItem__ptr node = (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), node_index))));
  nelua_GCItem value = node->value;
  if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
    (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex((&self->buckets), hash_index))) = node->next;
  } else {
    (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), prev_node_index))).next = node->next;
  }
  self->size = (self->size - 1);
  (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(node)) = (nelua_hashmapnode_pointer__GCItem_){.next = self->free_index};
  self->free_index = node_index;
  return value;
}
uintptr_t nelua_hashmap_pointer__GCItem__bucketcount(nelua_hashmap_pointer__GCItem__ptr self) {
  return self->buckets.size;
}
nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr nelua_hashmap_iteratorT_mnext(nelua_hashmap_iteratorT_ptr self, void* key) {
  if(NELUA_UNLIKELY((self->index == 0xffffffffffffffffULL))) {
    self->index = 0U;
  } else {
    self->index = (self->index + 1);
  }
  while((self->index < self->container->nodes.size)) {
    nelua_hashmapnode_pointer__GCItem__ptr node = (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->container->nodes), self->index))));
    if(node->filled) {
      return (nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr){true, node->key, (&node->value)};
    }
    self->index = (self->index + 1);
  }
  return (nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr){false, NULL, ((nelua_GCItem_ptr)NULL)};
}
nlmulret_function_Y9ZBzLsq6u97x8ch_nelua_hashmap_iteratorT_nlpointer nelua_hashmap_pointer__GCItem____mpairs(nelua_hashmap_pointer__GCItem__ptr self) {
  return (nlmulret_function_Y9ZBzLsq6u97x8ch_nelua_hashmap_iteratorT_nlpointer){nelua_hashmap_iteratorT_mnext, (nelua_hashmap_iteratorT){.container = self, .index = 0xffffffffffffffffULL}, NULL};
}
void nelua_vector_pointer__clear(nelua_vector_pointer__ptr self) {
  self->size = 0U;
}
void nelua_vector_pointer__destroy(nelua_vector_pointer__ptr self) {
  nelua_GeneralAllocator_spandealloc_1((&self->allocator), self->data);
  self->data = (nelua_span_pointer_){0};
  self->size = 0U;
}
void nelua_assert_line_8(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/vector.nelua\033[1m:117:17: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 82, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n      check(cap > self.data.size, 'capacity overflow')\n                \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~\033[0m\n", 1, 115, stderr);
    fflush(stderr);
    nelua_abort();
  }
}
void nelua_vectorT_grow(nelua_vector_pointer__ptr self) {
  uintptr_t cap = 1U;
  if(NELUA_LIKELY((self->data.size != 0))) {
    cap = (self->data.size * 2);
    nelua_assert_line_8((cap > self->data.size), ((nlstring){(uint8_t*)"capacity overflow", 17}));
  }
  self->data = nelua_GeneralAllocator_xspanrealloc_1((&self->allocator), self->data, cap);
}
void nelua_vector_pointer__push(nelua_vector_pointer__ptr self, void* v) {
  uintptr_t newsize = (self->size + 1);
  if(NELUA_UNLIKELY((newsize > self->data.size))) {
    nelua_vectorT_grow(self);
  }
  (*(void**)nelua_assert_deref(nelua_span_pointer____atindex((&self->data), self->size))) = v;
  self->size = newsize;
}
void nelua_assert_line_9(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/vector.nelua\033[1m:216:15: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 82, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    check(pos < self.size, 'position out of bounds')\n              \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 1, 106, stderr);
    fflush(stderr);
    nelua_abort();
  }
}
nlpointer_ptr nelua_vector_pointer____atindex(nelua_vector_pointer__ptr self, uintptr_t pos) {
  nelua_assert_line_9((pos < self->size), ((nlstring){(uint8_t*)"position out of bounds", 22}));
  return (&(*(void**)nelua_assert_deref(nelua_span_pointer____atindex((&self->data), pos))));
}
bool nelua_hasflag(uintptr_t flags, uintptr_t flag) {
  return ((flags & flag) != 0);
}
uintptr_t nelua_align_forward(uintptr_t addr, uintptr_t align) {
  return ((addr + (align - 1)) & (~(align - 1)));
}
bool nelua_GCItem_ismarked(nelua_GCItem_ptr self) {
  return nelua_hasflag(self->flags, 3U);
}
bool nelua_GC_unregister_1(nelua_GC_ptr self, void* ptr, bool finalize) {
  if(NELUA_UNLIKELY((!(ptr != NULL)))) {
    return false;
  }
  nelua_GCItem item = nelua_hashmap_pointer__GCItem__remove((&self->items), ptr);
  if(NELUA_UNLIKELY((item.ptr != ptr))) {
    return false;
  }
  if((!nelua_hasflag(item.flags, 2U))) {
    self->membytes = (self->membytes - item.size);
    for(uintptr_t i = 0U, _end = self->frees.size; i < _end; i = i + 1) {
      if(((*(void**)nelua_assert_deref(nelua_vector_pointer____atindex((&self->frees), i))) == ptr)) {
        (*(void**)nelua_assert_deref(nelua_vector_pointer____atindex((&self->frees), i))) = (void*)NULL;
        break;
      }
    }
  }
  if((finalize && (item.finalizer != NULL))) {
    item.finalizer(ptr, item.userdata);
  }
  return true;
}
void nelua_GC_markptrs(nelua_GC_ptr self, uintptr_t low, uintptr_t high) {
  uintptr_t minaddr = self->minaddr;
  uintptr_t maxaddr = self->maxaddr;
  nelua_hashmap_pointer__GCItem__ptr items = (&self->items);
  for(uintptr_t memaddr = low, _end = high; memaddr < _end; memaddr = memaddr + 8) {
    uintptr_t addr = (*(uintptr_t*)nelua_assert_deref((nlusize_ptr)memaddr));
    if(((addr >= minaddr) && (addr <= maxaddr))) {
      nelua_GCItem_ptr item = nelua_hashmap_pointer__GCItem__peek(items, (void*)addr);
      if(((item != NULL) && (!nelua_GCItem_ismarked(item)))) {
        item->flags = (item->flags | 1U);
        if((!nelua_hasflag(item->flags, 4U))) {
          nelua_GC_markptrs(self, addr, (addr + item->size));
        }
      }
    }
  }
}
void nelua_GC_unmarkall(nelua_GC_ptr self) {
  {
    nlmulret_function_Y9ZBzLsq6u97x8ch_nelua_hashmap_iteratorT_nlpointer _asgnret_1 = nelua_mpairs_1((&self->items));
    function_Y9ZBzLsq6u97x8ch __fornext = _asgnret_1.r1;
    nelua_hashmap_iteratorT __forstate = _asgnret_1.r2;
    void* __forit = _asgnret_1.r3;
    while(true) {
      bool __forcont;
      nelua_GCItem_ptr item;
      nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr _asgnret_2 = __fornext((&__forstate), __forit);
      __forcont = _asgnret_2.r1;
      __forit = _asgnret_2.r2;
      item = _asgnret_2.r3;
      if((!__forcont)) {
        break;
      }
      __forit;
      {
        item->flags = (item->flags & 18446744073709551614ULL);
      }
    }
  }
}
void nelua_GC_markroot(nelua_GC_ptr self) {
  {
    nlmulret_function_Y9ZBzLsq6u97x8ch_nelua_hashmap_iteratorT_nlpointer _asgnret_1 = nelua_mpairs_1((&self->items));
    function_Y9ZBzLsq6u97x8ch __fornext = _asgnret_1.r1;
    nelua_hashmap_iteratorT __forstate = _asgnret_1.r2;
    void* __forit = _asgnret_1.r3;
    while(true) {
      bool __forcont;
      nelua_GCItem_ptr item;
      nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr _asgnret_2 = __fornext((&__forstate), __forit);
      __forcont = _asgnret_2.r1;
      __forit = _asgnret_2.r2;
      item = _asgnret_2.r3;
      if((!__forcont)) {
        break;
      }
      void* ptr = __forit;
      {
        if(nelua_hasflag(item->flags, 2U)) {
          uintptr_t addr = (uintptr_t)ptr;
          nelua_GC_markptrs(self, addr, (addr + item->size));
        }
      }
    }
  }
}
uintptr_t nelua_assert_narrow_nlint64_nlusize(int64_t x) {
  if(NELUA_UNLIKELY(x < 0)) {
    nelua_panic_cstring("narrow casting from int64 to usize failed");
  }
  return (uintptr_t)x;
}
void nelua_GC_markstack(nelua_GC_ptr self) {
  nelua_RegsBuf regsbuf;
  setjmp(regsbuf.regs);
#if defined(__GNUC__) || defined(__clang__)
  volatile void* sp = __builtin_frame_address(0);
#endif
  uintptr_t low = ((self->stacktop == 0) ? (uintptr_t)(&regsbuf) : self->stacktop);
  uintptr_t high = self->stackbottom;
  if((high < low)) {
    uintptr_t _asgntmp_1 = high;
    uintptr_t _asgntmp_2 = low;
    low = _asgntmp_1;
    high = _asgntmp_2;
  }
  low = nelua_align_forward(low, 8U);
  nelua_GC_markptrs(self, low, high);
  nelua_GC_markptrs(self, (uintptr_t)(&regsbuf), nelua_assert_narrow_nlint64_nlusize((int64_t)((uintptr_t)(&regsbuf) + sizeof(nelua_RegsBuf))));
#if defined(__GNUC__) || defined(__clang__)
  nelua_GC_markptrs(self, (uintptr_t)(&sp), ((uintptr_t)(&sp) + 8));
#endif
}
void nelua_GC_mark(nelua_GC_ptr self) {
  nelua_GC_unmarkall(self);
  nelua_GC_markroot(self);
  volatile function_5MrVRYcrg5F8fqJVF markstack = nelua_GC_markstack;
  markstack(self);
}
void nelua_assert_line_10(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/allocators/gc.nelua\033[1m:239:15: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 89, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n        check(item, 'gc item not found to finalize')\n              \033[1m\033[32m^\033[0m\033[35m~~~\033[0m\n", 1, 99, stderr);
    fflush(stderr);
    nelua_abort();
  }
}
void nelua_assert_line_11(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/allocators/gc.nelua\033[1m:255:22: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 89, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n      check(item.ptr == ptr, 'gc item not found to deallocate')\n                     \033[1m\033[32m^\033[0m\033[35m~~~~~\033[0m\n", 1, 119, stderr);
    fflush(stderr);
    nelua_abort();
  }
}
void nelua_GC_sweep(nelua_GC_ptr self) {
  bool finalize = false;
  {
    nlmulret_function_Y9ZBzLsq6u97x8ch_nelua_hashmap_iteratorT_nlpointer _asgnret_1 = nelua_mpairs_1((&self->items));
    function_Y9ZBzLsq6u97x8ch __fornext = _asgnret_1.r1;
    nelua_hashmap_iteratorT __forstate = _asgnret_1.r2;
    void* __forit = _asgnret_1.r3;
    while(true) {
      bool __forcont;
      nelua_GCItem_ptr item;
      nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr _asgnret_2 = __fornext((&__forstate), __forit);
      __forcont = _asgnret_2.r1;
      __forit = _asgnret_2.r2;
      item = _asgnret_2.r3;
      if((!__forcont)) {
        break;
      }
      void* ptr = __forit;
      {
        if((!nelua_GCItem_ismarked(item))) {
          nelua_vector_pointer__push((&self->frees), ptr);
          if(((!finalize) && (item->finalizer != NULL))) {
            finalize = true;
          }
        }
      }
    }
  }
  if(finalize) {
    uintptr_t i = 0U;
    while((i < self->frees.size)) {
      void* ptr = (*(void**)nelua_assert_deref(nelua_vector_pointer____atindex((&self->frees), i)));
      if((ptr != NULL)) {
        nelua_GCItem_ptr item = nelua_hashmap_pointer__GCItem__peek((&self->items), ptr);
        nelua_assert_line_10((item != NULL), ((nlstring){(uint8_t*)"gc item not found to finalize", 29}));
        if(((item != NULL) && (item->finalizer != NULL))) {
          nelua_GCFinalizerCallback finalizer = item->finalizer;
          item->finalizer = (nelua_GCFinalizerCallback)NULL;
          finalizer(ptr, item->userdata);
        }
      }
      i = (i + 1);
    }
  }
  uintptr_t i = 0U;
  while((i < self->frees.size)) {
    void* ptr = (*(void**)nelua_assert_deref(nelua_vector_pointer____atindex((&self->frees), i)));
    if((ptr != NULL)) {
      nelua_GCItem item = nelua_hashmap_pointer__GCItem__remove((&self->items), ptr);
      nelua_assert_line_11((item.ptr == ptr), ((nlstring){(uint8_t*)"gc item not found to deallocate", 31}));
      if((item.ptr != NULL)) {
        self->membytes = (self->membytes - item.size);
        if((!nelua_hasflag(item.flags, 8U))) {
          nelua_GeneralAllocator_dealloc((&nelua_general_allocator), ptr);
        }
      }
    }
    i = (i + 1);
  }
  nelua_vector_pointer__clear((&self->frees));
}
void nelua_GC_collect(nelua_GC_ptr self) {
  if((self->collecting || (self->membytes == 0))) {
    return;
  }
  self->collecting = true;
  nelua_GC_mark(self);
  nelua_GC_sweep(self);
  self->lastmembytes = self->membytes;
  if(((self->items.size * 4) < nelua_hashmap_pointer__GCItem__bucketcount((&self->items)))) {
    nelua_hashmap_pointer__GCItem__rehash((&self->items), 0U);
  }
  self->collecting = false;
}
void nelua_GC_registerroots(nelua_GC_ptr self) {
  nelua_GC_register((&nelua_gc), (void*)(&main_shootsnd), 32U, 2U, (function_32GqvTv12hiL63Ei3)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&main_hit), 32U, 2U, (function_32GqvTv12hiL63Ei3)NULL, (void*)NULL);
}
void nelua_GC_maybecollect(nelua_GC_ptr self) {
  if(((self->running && (!self->collecting)) && ((self->membytes * 100) >= (self->lastmembytes * self->pause)))) {
    nelua_GC_collect(self);
  }
}
void nelua_assert_line_12(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/allocators/gc.nelua\033[1m:352:18: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 89, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n  check(item.ptr == nilptr, 'cannot register pointer twice')\n                 \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 1, 115, stderr);
    fflush(stderr);
    nelua_abort();
  }
}
void nelua_GC_register(nelua_GC_ptr self, void* ptr, uintptr_t size, uintptr_t flags, function_32GqvTv12hiL63Ei3 finalizer, void* userdata) {
  if(NELUA_UNLIKELY((!(ptr != NULL)))) {
    return;
  }
  if(NELUA_UNLIKELY((size < 8))) {
    flags = (flags | 4U);
  }
  nelua_GCItem_ptr item = (&(*(nelua_GCItem*)nelua_assert_deref(nelua_hashmap_pointer__GCItem____atindex((&self->items), ptr))));
  nelua_assert_line_12((item->ptr == (void*)NULL), ((nlstring){(uint8_t*)"cannot register pointer twice", 29}));
  (*(nelua_GCItem*)nelua_assert_deref(item)) = (nelua_GCItem){.flags = flags, .size = size, .ptr = ptr, .finalizer = finalizer, .userdata = userdata};
  if(NELUA_LIKELY((!nelua_hasflag(flags, 2U)))) {
    uintptr_t addr = (uintptr_t)ptr;
    uintptr_t addrhigh = (addr + size);
    if((addrhigh > self->maxaddr)) {
      self->maxaddr = addrhigh;
    }
    if((addr < self->minaddr)) {
      self->minaddr = addr;
    }
    self->membytes = (self->membytes + size);
    nelua_GC_maybecollect(self);
  }
}
void nelua_GC_restart(nelua_GC_ptr self) {
  self->running = true;
}
void nelua_GC_init(nelua_GC_ptr self, void* stack) {
  self->stackbottom = (uintptr_t)stack;
  self->minaddr = 0xffffffffffffffffULL;
  self->pause = 200U;
  nelua_GC_registerroots(self);
  nelua_GC_restart(self);
}
void nelua_GC_destroy(nelua_GC_ptr self) {
  nelua_GC_unmarkall(self);
  nelua_GC_sweep(self);
  nelua_hashmap_pointer__GCItem__destroy((&self->items));
  nelua_vector_pointer__destroy((&self->frees));
  (*(nelua_GC*)nelua_assert_deref(self)) = (nelua_GC){0};
}
int main(int argc, nlcstring_ptr argv) {
  nelua_GC_init((&nelua_gc), (void*)(&argc));
  volatile function_2PF4zy9rEcTmN3kR7 inner_main = nelua_main;
  int ret = inner_main(argc, argv);
  nelua_GC_destroy((&nelua_gc));
  return ret;
}
void* nelua_GCAllocator_alloc_1(nelua_GCAllocator_ptr self, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  uintptr_t flags_1 = 0U;
  nelua_GCFinalizerCallback finalizer_1 = (nelua_GCFinalizerCallback)NULL;
  void* userdata_1 = (void*)NULL;
  void* ptr = nelua_GeneralAllocator_alloc((&nelua_general_allocator), size);
  nelua_GC_register((&nelua_gc), ptr, size, flags_1, finalizer_1, userdata_1);
  return ptr;
}
void nelua_GCAllocator_dealloc(nelua_GCAllocator_ptr self, void* ptr) {
  nelua_GC_unregister_1((&nelua_gc), ptr, true);
  nelua_GeneralAllocator_dealloc((&nelua_general_allocator), ptr);
}
void* nelua_GCAllocator_xalloc(nelua_GCAllocator_ptr self, uintptr_t size) {
  void* p = nelua_GCAllocator_alloc_1(self, size, NELUA_NIL, NELUA_NIL, NELUA_NIL);
  if(NELUA_UNLIKELY(((p == (void*)NULL) && (size > 0)))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return p;
}
void nelua_assert_line_13(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/string.nelua\033[1m:34:14: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 81, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n  check(size > 0, 'attempt to create an empty string')\n             \033[1m\033[32m^\033[0m\033[35m~~\033[0m\n", 1, 99, stderr);
    fflush(stderr);
    nelua_abort();
  }
}
nlstring nelua_nlstring_create(uintptr_t size) {
  nelua_assert_line_13((size > 0), ((nlstring){(uint8_t*)"attempt to create an empty string", 33}));
  nlstring s = (nlstring){.data = ((nluint8_arr0_ptr)nelua_GCAllocator_xalloc((&nelua_gc_allocator), (size + 1))), .size = size};
  s.data[size] = 0U;
  return s;
}
void nelua_nlstring_destroy(nlstring_ptr self) {
  if(NELUA_UNLIKELY((self->size == 0))) {
    return;
  }
  nelua_GCAllocator_dealloc((&nelua_gc_allocator), (void*)self->data);
  self->data = ((nluint8_arr0_ptr)NULL);
  self->size = 0U;
}
nlstring nelua_nlstring_copy(nlstring s) {
  nlstring clone = {0};
  if(NELUA_UNLIKELY((s.size == 0))) {
    return clone;
  }
  clone.data = ((nluint8_arr0_ptr)nelua_GCAllocator_xalloc((&nelua_gc_allocator), (s.size + 1)));
  nelua_memory_copy((void*)clone.data, (void*)s.data, s.size);
  clone.data[s.size] = 0U;
  clone.size = s.size;
  return clone;
}
nlstring nelua_nlstring___concat_2(nlstring a, int64_t b) {
  nlstring b_1 = nelua_tostring_2(b);
  if((a.size == 0)) {
    nlstring _ret_1 = nelua_nlstring_copy(b_1);
    { /* defer */
      nelua_nlstring_destroy((&b_1));
    }
    return _ret_1;
  } else if((b_1.size == 0)) {
    nlstring _ret_2 = nelua_nlstring_copy(a);
    { /* defer */
      nelua_nlstring_destroy((&b_1));
    }
    return _ret_2;
  }
  nlstring s = nelua_nlstring_create((a.size + b_1.size));
  nelua_memory_copy((void*)s.data, (void*)a.data, a.size);
  nelua_memory_copy((void*)(&s.data[a.size]), (void*)b_1.data, b_1.size);
  { /* defer */
    nelua_nlstring_destroy((&b_1));
  }
  return s;
}
uintptr_t nelua_assert_bounds_nlusize(uintptr_t index, uintptr_t len) {
  if(NELUA_UNLIKELY((uintptr_t)index >= len)) {
    nelua_panic_cstring("array index: position out of bounds");
  }
  return index;
}
nlstring nelua_int2str_1(intptr_t x, nlniltype base) {
  if((x == 0)) {
    return nelua_nlstring_copy(((nlstring){(uint8_t*)"0", 1}));
  }
  nluint8_arr48 buf;
  uintptr_t pos = 47U;
  bool neg = (x < 0);
  while((x != 0)) {
    intptr_t quot = (x / 10);
    intptr_t rema = (x - (quot * 10));
    if((rema < 0)) {
      rema = (-rema);
    }
    x = quot;
    buf.v[nelua_assert_bounds_nlusize(pos, 48)] = (uint8_t)(rema + 48);
    pos = (pos - 1);
  }
  if(neg) {
    buf.v[nelua_assert_bounds_nlusize(pos, 48)] = 45U;
    pos = (pos - 1);
  }
  buf.v[nelua_assert_bounds_nlusize(pos, 48)] = 0U;
  return nelua_nlstring_copy((nlstring){.data = ((nluint8_arr0_ptr)(&buf.v[nelua_assert_bounds_nlusize((pos + 1), 48)])), .size = ((48 - pos) - 1)});
}
nlstring nelua_tostring_2(int64_t x) {
  return nelua_int2str_1((intptr_t)x, NELUA_NIL);
}
void nelua_os_exit_1(nlniltype code) {
  exit(EXIT_SUCCESS);
}
void nelua_print_1(nlstring a1) {
  if(a1.size > 0) {
    fwrite(a1.data, 1, a1.size, stdout);
  }
  fputc('\n', stdout);
  fflush(stdout);
}
void nelua_print_2(int64_t a1) {
  fprintf(stdout, "%lli", (long long)a1);
  fputc('\n', stdout);
  fflush(stdout);
}
void nelua_print_3(float a1, float a2) {
  int len;
  bool fractnum;
  char buff[48];
  buff[sizeof(buff)-1] = 0;
  len = snprintf(buff, sizeof(buff)-1, "%.7g", a1);
  fractnum = false;
  for(int i=0;i<len && buff[i] != 0;++i) {
    if(!((buff[i] >= '0' && buff[i] <= '9') || buff[i] == '-')) {
      fractnum = true;
      break;
    }
  }
  if(!fractnum && len > 0 && len + 2 < (int)sizeof(buff)) {
    buff[len] = '.';
    buff[len+1] = '0';
    len = len + 2;
  }
  fwrite(buff, 1, len, stdout);
  fputc('\t', stdout);
  len = snprintf(buff, sizeof(buff)-1, "%.7g", a2);
  fractnum = false;
  for(int i=0;i<len && buff[i] != 0;++i) {
    if(!((buff[i] >= '0' && buff[i] <= '9') || buff[i] == '-')) {
      fractnum = true;
      break;
    }
  }
  if(!fractnum && len > 0 && len + 2 < (int)sizeof(buff)) {
    buff[len] = '.';
    buff[len+1] = '0';
    len = len + 2;
  }
  fwrite(buff, 1, len, stdout);
  fputc('\n', stdout);
  fflush(stdout);
}
main_direct nelua_assert_bounds_main_direct(main_direct index, uintptr_t len) {
  if(NELUA_UNLIKELY((uintptr_t)index >= len || index < 0)) {
    nelua_panic_cstring("array index: position out of bounds");
  }
  return index;
}
char* nelua_assert_string2cstring(nlstring s) {
  if(s.size == 0) {
    return (char*)"";
  }
  if(NELUA_UNLIKELY(s.data[s.size]) != 0) {
    nelua_panic_cstring("attempt to convert a non null terminated string to cstring");
  }
  return (char*)s.data;
}
int nelua_main(int nelua_argc, char** nelua_argv) {
  main_scrn = (Rectangle){0.0f, 0.0f, 800.0f, 450.0f};
  main_enemy = (Rectangle){(float)GetRandomValue(50, 750), (float)GetRandomValue(50, 400), 50.0f, 50.0f};
  main_camera.target = (Vector2){0.0f, 0.0f};
  InitAudioDevice();
  InitWindow(800, 450, "shoot the red");
  if((!IsAudioDeviceReady())) {
    nelua_os_exit_1(NELUA_NIL);
  }
  SetMasterVolume(0.06f);
  main_shootsnd = LoadSoundFromWave(LoadWave("snd/shoot.wav"));
  main_hit = LoadSoundFromWave(LoadWave("snd/hit.wav"));
  SetTargetFPS(60);
  nelua_print_1(((nlstring){(uint8_t*)"OK", 2}));
  while((!WindowShouldClose())) {
    switch(main_direction) {
      case 0: {
        main_line.v[0].x = (main_plr.x + (main_plr.width / 2));
        main_line.v[1].x = (main_plr.x + (main_plr.width / 2));
        main_line.v[0].y = (main_plr.y - 25);
        main_line.v[1].y = (main_line.v[0].y - 25);
        break;
      }
      case 1: {
        main_line.v[0].x = (main_plr.x + (main_plr.width / 2));
        main_line.v[1].x = (main_plr.x + (main_plr.width / 2));
        main_line.v[0].y = (main_plr.y + 75);
        main_line.v[1].y = (main_line.v[0].y + 25);
        break;
      }
      case 3: {
        main_line.v[0].x = (main_plr.x + 75);
        main_line.v[1].x = (main_line.v[0].x + 25);
        main_line.v[0].y = (main_plr.y + (main_plr.height / 2));
        main_line.v[1].y = (main_plr.y + (main_plr.height / 2));
        break;
      }
      case 2: {
        main_line.v[0].x = (main_plr.x - 25);
        main_line.v[1].x = (main_line.v[0].x - 25);
        main_line.v[0].y = (main_plr.y + (main_plr.height / 2));
        main_line.v[1].y = (main_plr.y + (main_plr.height / 2));
        break;
      }
    }
    if(IsKeyDown(340)) {
      nelua_print_2(main_direction);
    }
    if(IsKeyDown(68)) {
      main_direction = 3;
      main_plr.x = (main_plr.x + (500 * GetFrameTime()));
    }
    if(IsKeyDown(65)) {
      main_direction = 2;
      main_plr.x = (main_plr.x - (500 * GetFrameTime()));
    }
    if(IsKeyDown(83)) {
      main_direction = 1;
      main_plr.y = (main_plr.y + (500 * GetFrameTime()));
    }
    if(IsKeyDown(87)) {
      main_direction = 0;
      main_plr.y = (main_plr.y - (500 * GetFrameTime()));
    }
    if(IsKeyPressed(32)) {
      PlaySound(main_shootsnd);
      if((main_direction > 1)) {
        main_newblt.pos.width = 30.0f;
        main_newblt.pos.height = 5.0f;
        main_newblt.pos.x = main_line.v[1].x;
        main_newblt.pos.y = (main_line.v[1].y - 2);
        main_newblt.dir = (main_direct)main_direction;
      } else if((main_direction < 2)) {
        main_newblt.pos.width = 5.0f;
        main_newblt.pos.height = 30.0f;
        main_newblt.pos.x = (main_line.v[1].x - (main_newblt.pos.width / 2));
        main_newblt.pos.y = main_line.v[1].y;
        main_newblt.dir = (main_direct)main_direction;
        nelua_print_3(main_newblt.pos.x, main_newblt.pos.y);
      }
      main_shoot = true;
    }
    if(main_shoot) {
      if(CheckCollisionRecs(main_scrn, main_newblt.pos)) {
        nelua_print_1(((nlstring){(uint8_t*)"collision found!", 16}));
        if((main_newblt.dir < 2)) {
          main_newblt.pos.y = (main_newblt.pos.y + ((1500 * GetFrameTime()) * main_dict.v[nelua_assert_bounds_main_direct(main_newblt.dir, 4)]));
        } else if((main_newblt.dir > 1)) {
          main_newblt.pos.x = (main_newblt.pos.x + ((1500 * GetFrameTime()) * main_dict.v[nelua_assert_bounds_main_direct(main_newblt.dir, 4)]));
        }
        if(CheckCollisionRecs(main_enemy, main_newblt.pos)) {
          PlaySound(main_hit);
          main_enemy.x = (float)GetRandomValue(50, 750);
          main_enemy.y = (float)GetRandomValue(50, 400);
          main_score = (main_score + 1);
        }
      } else {
        nelua_print_1(((nlstring){(uint8_t*)"not colliding", 13}));
        main_newblt.pos.x = 10.0f;
        main_newblt.pos.y = 10.0f;
        main_shoot = false;
      }
    }
    BeginDrawing();
    ClearBackground(LIGHTGRAY);
    DrawRectanglePro(main_newblt.pos, (Vector2){0.0f, 0.0f}, 0.0f, YELLOW);
    DrawRectanglePro(main_plr, (Vector2){0.0f, 0.0f}, 0.0f, LIME);
    DrawRectanglePro(main_enemy, (Vector2){0.0f, 0.0f}, 0.0f, RED);
    DrawLineEx(main_line.v[0], main_line.v[1], 5.0f, BLUE);
    BeginMode2D(main_camera);
    {
      main_camera.target.x = main_plr.x;
      main_camera.target.y = main_plr.y;
    }
    EndMode2D();
    DrawFPS(0, 0);
    DrawText(nelua_assert_string2cstring(nelua_nlstring___concat_2(((nlstring){(uint8_t*)"Score: ", 7}), main_score)), 100, 0, 20, WHITE);
    EndDrawing();
  }
  UnloadSound(main_hit);
  UnloadSound(main_shootsnd);
  CloseAudioDevice();
  CloseWindow();
  return 0;
}
